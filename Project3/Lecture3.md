# 南开大学 高级语言程序设计 Lecture 3


## 一、array：固定大小的高效容器
### 1. 核心特性
C++11新增的array，在C数组基础上封装，无额外运行开销：
- **固定大小**：编译时确定大小，不可修改；
- **静态存储**：元素存于栈或静态区，分配快；
- **安全访问**：`at()`方法做边界检查（越界抛异常），`[]`无检查（快速）；
- **兼容算法**：支持迭代器与范围for循环，可直接用STL算法。

### 2. 关键功能与场景
- 常用功能：`size()`（固定大小）、`fill()`（批量填充）、`swap()`（同类型同大小容器交换）、`data()`（获取底层数组指针，兼容C接口）；
- 适用场景：固定长度数据（如RGB值、月份天数）、性能敏感代码、需避免数组退化的参数传递。


## 二、vector：动态灵活的动态数组
### 1. 核心特性
STL最常用容器，封装动态数组：
- **动态大小**：运行时可增删元素，自动管理内存；
- **连续存储**：支持O(1)随机访问，尾部操作（`push_back`/`pop_back`）均摊O(1)；
- **扩容机制**：容量不足时，分配原容量1.5~2倍新空间（编译器差异），拷贝旧元素后释放旧空间；
- **迭代器风险**：扩容或中间插入/删除时，迭代器可能失效（需重新获取）。

### 2. 关键功能与场景
- 常用功能：`reserve()`（预分配容量，减少扩容）、`emplace_back()`（直接构造元素，比`push_back`高效）、`insert()`/`erase()`（中间操作，O(n)复杂度）、`shrink_to_fit()`（收缩容量匹配大小）；
- 适用场景：元素数量不确定（如用户输入）、需频繁尾部操作、需与C接口交互（`data()`获取指针）。

## 三、string：灵活高效的字符串容器  
### 1. 核心特性  
C++标准库中专门处理字符串的容器，封装了动态字符序列：  
- **动态管理**：自动处理内存分配与释放，长度可动态增减，无需手动管理缓冲区；  
- **兼容C串**：底层以`\0`结尾（`c_str()`可直接转换为C风格字符串），无缝对接C语言接口；  
- **安全操作**：提供`at()`做边界检查（越界抛异常），避免C风格字符串的缓冲区溢出风险；  
- **丰富接口**：内置字符串拼接、查找、替换等操作，无需手动实现（如`+=`、`find()`、`replace()`）。  


### 2. 关键功能与场景  
- 常用功能：  
  - 初始化：支持从C串（`"hello"`）、重复字符（`string(3, 'a')`）、其他string拷贝等多种方式；  
  - 访问：`[]`快速访问（无检查）、`at()`安全访问（有检查）、`front()`/`back()`获取首尾字符；  
  - 修改：`+=`/`append()`拼接字符串，`insert()`/`erase()`插入删除子串，`replace()`替换部分内容；  
  - 查找：`find()`正向查找子串位置，`rfind()`反向查找，`substr()`提取子串；  
  - 管理：`size()`获取长度，`empty()`判空，`reserve()`预分配容量（减少扩容）。  

- 适用场景：  
  - 文本处理（如日志生成、字符串解析）；  
  - 用户输入输出（如读取命令行参数、界面文本）；  
  - 字符串拼接与格式化（替代C语言`sprintf`，更安全）；  
  - 与C库交互（通过`c_str()`传递字符串给C函数）。

## 四、指针与动态内存分配  
### 1. 核心特性  
指针是存储内存地址的变量，动态内存分配允许程序在运行时灵活申请/释放内存，二者结合是C++直接操作内存的核心机制：  
- **地址存储**：指针变量存储另一个变量的内存地址（而非值），通过`*`运算符可访问地址指向的内容（解引用）；  
- **动态性**：动态内存（堆内存）在运行时通过`new`申请、`delete`释放，大小可根据程序需求动态调整（区别于编译时确定的栈内存/静态内存）；  
- **手动管理**：动态内存的生命周期不由编译器自动管理，需开发者显式释放，否则会导致内存泄漏；  
- **灵活性与风险并存**：可直接操作硬件地址、实现复杂数据结构（如链表、树），但易出现野指针（指向无效地址）、悬垂指针（指向已释放内存）等问题。  


### 2. 关键功能与场景  
- 常用功能：  
  - 指针声明与初始化：`int* p;`（声明int型指针）、`int a=5; p=&a;`（指向变量a的地址）、`p=nullptr;`（空指针，避免野指针）；  
  - 动态内存分配：`int* p = new int(10);`（申请单个int并初始化为10）、`int* arr = new int[5];`（申请int数组，含5个元素）；  
  - 内存释放：`delete p;`（释放单个动态变量）、`delete[] arr;`（释放动态数组，必须与`new[]`配对）；  
  - 指针运算：`p++`（指向相邻内存单元，步长为指针类型大小）、`p+n`（指向偏移n个类型大小的地址）；  
  - 指针与数组：数组名本质是指向首元素的常量指针（`int arr[3]; int* p=arr;`等价于`p=&arr[0]`）。  

- 适用场景：  
  - 动态大小数据：如存储用户输入的不确定长度数据（替代固定大小数组）；  
  - 复杂数据结构：实现链表、二叉树等需动态增减节点的结构（节点内存需动态申请）；  
  - 高效参数传递：传递大型对象时，通过指针传递地址（避免值传递的拷贝开销）；  
  - 跨作用域数据共享：函数中申请的动态内存可通过指针返回给调用方（需注意后续释放）。  

- 风险与规避：  
  - 内存泄漏：忘记用`delete`释放动态内存，导致程序持续占用内存（可通过智能指针`unique_ptr`/`shared_ptr`自动管理）；  
  - 野指针：未初始化或指向已释放内存的指针（始终用`nullptr`初始化未使用的指针）；  
  - 二次释放：对同一动态内存多次调用`delete`（释放后立即置为`nullptr`，避免重复操作）。

## 五、变量的作用域、生存期与内存分配区域  
在C++中，变量的**作用域**（能被访问的代码范围）、**生存期**（从创建到销毁的时间段）与**内存分配区域**（存储在内存的哪个位置）三者紧密关联——内存区域决定了变量的生存期，而生存期又影响作用域的设计。下面结合之前学过的指针、动态内存等知识，介绍这三个核心概念。


## 1. 核心概念定义  
先明确三个基础概念的本质，避免混淆：  
| 概念         | 核心含义                                                                 |
|--------------|--------------------------------------------------------------------------|
| 作用域（Scope） | 变量“可见”的代码范围，超出范围则无法直接访问（需通过指针等间接方式）。   |
| 生存期（Lifetime） | 变量从“内存分配”到“内存释放”的时间段，生存期结束后变量的值会失效。       |
| 内存分配区域   | 变量在计算机内存中存储的具体位置，不同区域的内存管理规则（分配/释放）不同。 |


## 2. 四大内存区域与变量对应关系  
C++程序运行时，内存主要分为**栈、堆、全局/静态存储区、常量区**四大区域，不同区域的变量具有截然不同的作用域和生存期。


### 2.1 栈（Stack）：自动管理的“临时内存”  
#### 区域特点  
- **自动分配与释放**：由编译器自动管理，变量进入代码块（如函数、`if`/`for`块）时分配内存，离开代码块时自动释放（“先进后出”，类似栈数据结构）；  
- **内存空间有限**：栈的大小固定（通常几MB到几十MB，由操作系统决定），超出会导致“栈溢出”（如递归调用过深、局部数组过大）；  
- **访问速度快**：栈位于CPU高速缓存附近，访问效率远高于堆。  

#### 对应变量类型  
- 函数内的**局部变量**（如`int a = 10;`、`double b;`）；  
- 函数的**形参**（如`void func(int x)`中的`x`）；  
- 代码块内的临时变量（如`for(int i=0; i<5; i++)`中的`i`）。  

#### 作用域与生存期  
- **作用域**：仅限变量所在的“代码块”（函数、`if`/`for`/`while`块，用`{}`包裹的区域）；  
- **生存期**：从变量定义的代码行开始，到离开代码块时结束（即使变量未显式赋值，生存期也会按规则结束）。  

#### 示例与注意事项  
```cpp
void func() {
    int x = 10; // x在栈上，作用域：func函数内，生存期：func调用期间
    if (x > 5) {
        double y = 3.14; // y在栈上，作用域：if块内，生存期：离开if块后释放
        cout << y << endl; // 合法：在y的作用域内
    }
    // cout << y << endl; // 错误：y的作用域已结束，无法访问
} // func结束后，x的生存期结束，栈内存自动释放
```
**常见问题**：避免返回栈变量的地址——栈变量生存期随代码块结束而结束，返回其地址会导致“野指针”（指向已释放的无效内存）：  
```cpp
int* badFunc() {
    int x = 10;
    return &x; // 错误：x在栈上，func结束后x的内存释放，返回的地址无效
}
```


### 2.2 堆（Heap）：手动管理的“动态内存”  
#### 区域特点  
- **手动分配与释放**：需通过`new`（分配）和`delete`（释放）显式控制，编译器不干预；  
- **内存空间大**：堆的大小由系统空闲内存决定（通常几GB到几十GB），适合存储大型数据；  
- **访问速度慢**：堆位于内存物理地址较远区域，需通过指针间接访问，效率低于栈。  

#### 对应变量类型  
- 用`new`分配的**动态变量**（如`int* p = new int(20);`）；  
- 用`new[]`分配的**动态数组**（如`double* arr = new double[5];`）；  
- STL容器的底层数据（如`vector`的元素、`string`的字符序列）——容器对象本身可能在栈，但元素存储在堆（如`vector<int> vec;`中`vec`在栈，元素在堆）。  

#### 作用域与生存期  
- **作用域**：无固定作用域——只要持有指向堆内存的有效指针，在程序任何位置都能访问（跨函数、跨文件均可）；  
- **生存期**：从`new`分配成功开始，到`delete`释放结束（若未`delete`，程序结束后由操作系统回收，否则导致“内存泄漏”）。  

#### 示例与注意事项  
```cpp
void func() {
    // 1. 堆上分配动态变量
    int* p = new int(30); // p（指针变量）在栈上，指向的30在堆上
    cout << *p << endl; // 合法：通过指针访问堆内存，作用域无限制
    
    // 2. 堆上分配动态数组
    int* arr = new int[3]{1,2,3}; 
    cout << arr[1] << endl; // 合法：访问堆数组元素
    
    // 3. 手动释放堆内存（必须做，否则泄漏）
    delete p;   // 释放单个动态变量
    delete[] arr; // 释放动态数组（必须用delete[]，与new[]配对）
    p = nullptr; // 释放后将指针置空，避免悬垂指针
    arr = nullptr;
}
```
**常见问题**：  
- 内存泄漏：忘记`delete`，堆内存持续占用（如循环中`new`但不`delete`）；  
- 二次释放：对同一堆内存多次`delete`（如`delete p; delete p;`），导致程序崩溃；  
- 悬垂指针：指针指向的堆内存已释放，但指针未置空（后续访问会触发未定义行为）。


### 2.3 全局/静态存储区（Global/Static Area）：程序级的“持久内存”  
#### 区域特点  
- **自动分配与释放**：由操作系统在程序启动时分配，程序退出时自动释放；  
- **内存空间适中**：大小介于栈和堆之间，存储全局和静态变量；  
- **初始化规则**：未显式初始化的变量会被默认初始化为0（栈/堆变量未初始化时是随机值）。  

#### 对应变量类型  
- **全局变量**：定义在函数、类之外的变量（如`int g_count = 0;`）；  
- **静态变量**：用`static`修饰的变量：  
  - 静态局部变量（如`void func() { static int s_x = 1; }`）；  
  - 静态全局变量（如`static double s_pi = 3.14;`）；  
  - 类的静态成员变量（如`class A { static int s_num; };`）。  

#### 作用域与生存期  
| 变量类型       | 作用域                                                                 | 生存期                 |
|----------------|------------------------------------------------------------------------|------------------------|
| 全局变量       | 整个程序（所有源文件均可访问，需用`extern`声明跨文件访问）。           | 整个程序运行期间       |
| 静态全局变量   | 仅限当前源文件（避免跨文件命名冲突）。                                 | 整个程序运行期间       |
| 静态局部变量   | 仅限所在函数（与普通局部变量作用域相同），但**只初始化一次**。         | 整个程序运行期间       |

#### 示例与注意事项  
```cpp
// 1. 全局变量（全局/静态区）
int g_a = 100; 
static int g_b = 200; // 静态全局变量，仅限当前文件访问

void func1() {
    // 2. 静态局部变量（全局/静态区，只初始化一次）
    static int s_x = 0; 
    s_x++; // 每次调用func1，s_x自增（普通局部变量会重置为0）
    cout << s_x << endl; // 第一次1，第二次2，...
}

void func2() {
    cout << g_a << endl; // 合法：全局变量作用域覆盖整个程序
    // cout << g_b << endl; // 错误：g_b是静态全局变量，仅限定义它的文件访问
}

int main() {
    func1(); // 输出1
    func1(); // 输出2
    func2(); // 输出100
    return 0;
} // 程序结束后，g_a、g_b、s_x的内存自动释放
```
**关键特性**：静态局部变量的“只初始化一次”——即使函数多次调用，静态局部变量仅在第一次调用时初始化，后续调用直接使用上次的值（适合实现“计数器”“单例模式”等场景）。


### 2.4 常量区（Constant Area）：只读的“固定内存”  
#### 区域特点  
- **只读属性**：存储的数据无法修改（强行修改会触发程序崩溃）；  
- **自动分配与释放**：程序启动时分配，退出时释放；  
- **存储内容**：字符串常量、`const`修饰的全局/静态常量。  

#### 对应变量类型  
- **字符串常量**：如`"hello world"`（用`char* str = "hello";`时，`"hello"`在常量区，`str`指针在栈上）；  
- **const修饰的全局常量**：如`const int c_max = 1000;`（全局作用域的`const`变量）；  
- **const修饰的静态常量**：如`static const double c_pi = 3.1415;`。  

#### 作用域与生存期  
- **作用域**：与全局/静态变量一致（全局常量跨文件访问，静态常量限当前文件/函数）；  
- **生存期**：整个程序运行期间，且内存只读。  

#### 示例与注意事项  
```cpp
// 1. 全局const常量（常量区）
const int c_global = 500; 

void func() {
    // 2. 字符串常量（常量区）
    char* str1 = "hello"; // "hello"在常量区，str1在栈上
    // str1[0] = 'H'; // 错误：常量区数据只读，修改会崩溃
    
    // 3. const局部变量（注意：若为基础类型，可能存在栈上；若为字符串，仍在常量区）
    const int c_local = 100; // 基础类型const局部变量，通常优化到栈上（只读）
    char* str2 = "world"; // "world"仍在常量区
}

int main() {
    cout << c_global << endl; // 合法：全局const常量作用域覆盖整个程序
    func();
    return 0;
}
```
**关键区别**：`const`局部变量与全局`const`变量的存储差异——基础类型的`const`局部变量（如`const int c_local`）可能被编译器优化到栈上（但仍只读），而字符串常量（如`"hello"`）无论定义在何处，都始终存储在常量区。


## 3. 三者关联与总结  
变量的**内存区域**是“因”，**生存期**是“果”，而**作用域**是“访问规则”——通过内存区域可直接推断变量的生存期和作用域：  

| 内存区域       | 变量类型                 | 作用域特点               | 生存期特点               | 管理方式       |
|----------------|--------------------------|--------------------------|--------------------------|----------------|
| 栈（Stack）    | 局部变量、函数形参       | 代码块内可见             | 代码块结束释放           | 编译器自动管理 |
| 堆（Heap）     | 动态变量、动态数组       | 持指针即可访问（无限制） | `new`到`delete`之间      | 手动管理（new/delete） |
| 全局/静态区    | 全局变量、静态变量       | 全局/文件/函数内可见     | 程序启动到退出           | 操作系统自动管理 |
| 常量区         | 字符串常量、全局const常量 | 全局/文件内可见          | 程序启动到退出           | 操作系统自动管理（只读） |


## 4. 常见问题与避坑指南  
1. **局部变量返回地址**：栈变量生存期随代码块结束，返回其地址会导致野指针（解决方案：返回动态内存或静态局部变量的地址）；  
2. **堆内存泄漏**：忘记`delete`动态内存（解决方案：用智能指针`unique_ptr`/`shared_ptr`自动管理，避免手动`new/delete`）；  
3. **静态变量滥用**：静态变量会延长生存期，可能导致线程安全问题（解决方案：非必要不使用静态变量，多线程场景加锁）；  
4. **常量区修改**：试图修改字符串常量（解决方案：用`char[]`存储可修改的字符串，如`char str[] = "hello";`，`str`在栈上）。  

## 指针和动态内存分配在后续学习链表、树等数据结构的学习中很常用。
## 为了好理解指针这一数据类型，建议声名时写成int* ptr而不是int *ptr；
## * 在声明中表示该变量为指针类型，而在运算上表示“解引用”——把对应地址的值取出来
## & 在声明中表示该变量为引用类型（参见下一讲），而在运算上表示取址
## *，&可以视作“逆运算”

## 六、智能指针
智能指针是封装原始指针的模板类，通过**RAII机制**（对象析构时自动释放资源）解决动态内存管理问题（泄漏、重复释放、悬垂指针）。  

### 三种核心类型（定义于`<memory>`）  

#### 1. `std::unique_ptr`  
- **特点**：独占所有权（同一内存只能被一个`unique_ptr`管理），不可复制，仅可移动（`std::move`转移所有权）。  
- **场景**：管理局部动态对象、动态数组等独占资源。  


#### 2. `std::shared_ptr`  
- **特点**：共享所有权，通过**引用计数**追踪使用者数量（计数为0时自动释放）。  
- **问题**：循环引用会导致计数无法归零（内存泄漏）。  


#### 3. `std::weak_ptr`  
- **特点**：弱引用，不拥有所有权，不影响`shared_ptr`的引用计数，用于解决循环引用。  


#### 关键注意事项  
1. 优先用`std::make_unique`/`std::make_shared`创建，而非直接用`new`。  
2. 避免多个智能指针管理同一原始指针（会重复释放）。  
3. `shared_ptr`管理数组时需指定删除器（默认用`delete`而非`delete[]`）。  


#### 总结  
- `unique_ptr`：独占资源，轻量高效。  
- `shared_ptr`：共享资源，需注意循环引用。  
- `weak_ptr`：配合`shared_ptr`解决循环引用。  

智能指针是现代C++内存管理的首选，彻底替代手动`new`/`delete`。