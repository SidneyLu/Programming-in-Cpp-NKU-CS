# 南开大学 高级语言程序设计 Lecture 10

## 一、概念 Concept
模板的要求传统上是隐含的，具体取决于模板在运算符、函数调用中如何使用它的实参。比方说实参必须支持用基于范围的for循环来遍历，或者必须支持重载的<<来输出。虽然这些要求在生产级别的代码中通常都会用注释写明，但是编译器无法利用注释来加以约束。因此为了确定一个类型和模板不兼容，编译器必须先尝试实例化模板——由此触发许多令人费解的错误。**在初写模板时你一定领教过满屏爆红的威力**

概念在代码中显式指定了模板要求，使编译器能在实例化模板之前确定该类型是否与模板兼容。相较于之前C++模板的SFINAE（Substitution Failure Is Not An Error）机制，极大改善了错误提示的可读性和代码维护难度

C++20标准库在`<concept>`头文件中预定义了数十个Concept，覆盖了类型关系、数值类型、可调用性等场景。
|类别	|示例 Concept	|含义|
|-------|--------------|---|
类型关系|	std::same_as<T, U>|	T 和 U 是同一类型 |
--------|std::derived_from<T, Base>|	T 派生于 Base 类 |
数值类型 |	std::integral<T> |	T 是整型（int/char 等）
--------|std::floating_point<T>|	T 是浮点型（double/float 等）
可调用性|	std::invocable<F, Args...>|	可调用对象 F 能以 Args 为参数调用
容器特性|	std::ranges::range<R>|	R 是一个范围（支持 begin ()/end ()）

## 二、反射 Reflection
**反射（Reflection）** 指程序在运行时检查、修改自身结构（如类型信息、成员变量、成员函数等）的能力。与 Java、C# 等语言不同，C++ 原生不支持反射（设计上更强调静态类型检查和性能，编译期会擦除大部分类型元信息），但可通过一些技术模拟反射的部分功能。

1. RTTI（运行时类型识别）：
RTTI 是 C++ 提供的最基础 “反射” 能力，包含两个关键字：
    - typeid：获取类型的 type_info 对象（可获取类型名称）；
    - dynamic_cast：在多态继承中，检查类型并安全转换指针 / 引用。

2. 模板元编程（TMP）：
模板元编程可在编译期提取类型信息（如成员变量、函数签名），并生成对应逻辑，实现 “编译期反射”

应用场景：
- 序列化 / 反序列化：遍历对象成员，自动将对象转为 JSON/XML 等格式；
- 依赖注入：运行时根据类型信息创建对象，注入到依赖中；
- 调试工具：打印对象的所有成员值，辅助调试；
- 脚本绑定：将C++类暴露给Python等脚本语言，实现跨语言调用。


## 三、模板元编程 TMP
**模板元编程**是以 C++ 模板为基础，在编译期执行逻辑、计算值、生成代码的编程范式——它把 运行时做的事（如计算、类型判断）提前到编译期完成，本质是**用模板语法写的编译脚本**。TMP依赖C++模板的编译期实例化机制：
当你定义模板（如`template<int N> struct Fact`）并使用具体参数（如`Fact<5>`）时，编译器会：
1. 递归解析模板参数的逻辑（如阶乘的`N * Fact<N-1>::value`）；
2. 生成对应参数的 “具体模板实例”（如`struct Fact<5> { static const int value = 120; }`）；
3. 直接将编译期计算的结果（如 120）嵌入最终代码，运行时无需再计算。

普通模板是**类型参数化**，TMP是**逻辑参数化**，TMP很抽象、繁琐，却是之前提到的很多特性的底层支撑：
1. 编译期类型检查（Concept 的基础）
C++20 Concept 能 “约束模板参数类型”，底层依赖 TMP 的类型判断能力 —— 比如 std::integral<T> 就是用 TMP 实现的类型 trait（特性）。
2. 生成反射元数据（模拟反射的核心）
之前讲 “C++ 模拟反射” 时，需要在编译期收集类成员信息—— 这正是 TMP 的强项：通过模板递归遍历类成员，生成成员列表的元数据（如 std::tuple 包装成员指针）。
3. 零运行时开销的工具类
标准库中大量工具（如 std::enable_if、std::conditional）都是 TMP 实现的，比如 std::enable_if 可 “根据条件启用 / 禁用模板”，完全在编译期完成，不影响运行时性能。