# 南开大学 高级语言程序设计 Lecture 11

## 一、为什么需要模块？

传统头文件靠`#include`实现代码复用，却给大型项目带来诸多问题：
1. **重复编译慢**：头文件会被每个包含它的源文件“复制粘贴”，10个文件包含同一个头文件，就重复编译10次，项目大了编译要等几分钟；
2. **命名污染**：头文件里的全局函数、宏定义会暴露到所有包含它的代码中，不小心重名就报错；
3. **依赖混乱**：要纠结头文件包含顺序（比如先`#include Student.h`还是`Course.h`），还得写`#ifndef`保护宏防重复包含；
4. **接口实现混叠**：改个头文件里的内联函数（实现），即便类的接口没动，所有依赖代码都要重编。

模块从根本上解决这些问题，让OOP项目的编译、维护更轻松。


## 二、模块是什么？

模块是C++20的“独立编译单元”：而类是“封装功能单元”，模块是“类的编译容器”


## 三、模块的核心优势？

1. **独立编译**：模块只编译一次，生成中间文件，后续导入时直接用，不用重复编译。
2. **显式导出**：只有`export`的内容才对外暴露，比如`export class Student { ... }`，内部辅助函数不导出，不会和其他代码重名；
3. **无预处理依赖，不用纠结顺序**：不用写`#ifndef`保护宏，`import`模块的顺序不影响编译（先`import Student`还是`Course`都一样）；
4. **完全兼容OOP特性**：支持类、继承、多态——在模块里定义`Student`类，导出后其他模块能继承它写`GraduateStudent`，也能用父类指针实现多态，和头文件用法一致，只是编译更快。


## 四、模块怎么用？

1. **定义模块**：新建`.cppm`文件（跨平台模块后缀）或`.ixx`文件（MSVC后缀），开头用`export module 模块名;`声明（比如`export module Student;`），然后定义并导出OOP组件（如`export class Student { ... };`）；
2. **编译模块**：用支持C++20的编译器（VS2022、GCC11+）编译，生成中间文件（如MSVC的`.ifc`、GCC的`.gcm`）；
3. **导入使用**：在主程序或其他模块中用`import 模块名;`（比如`import Student;`），就能像用头文件类一样创建对象、调用方法，编译时链接模块中间文件即可。


### 从小项目重构开始：把之前写的1-2个类（如`Student`、`DateTime`）改成模块，体验编译速度变化

## 五、简单聊聊C++编译
把大象装进冰箱，总共分四步
### 1. 预处理：
- **预处理器**负责处理`#`开头指令（`#include`慢就慢在这）
- 输出：纯代码文本（`.i`文件）


### 2. 编译：
- **编译器前端**负责语法和语义检查
- **编译器后端**负责代码优化和目标代码生成
- 输出：汇编文件（`.s`文件）


### 3. 汇编：
- **汇编器**负责把汇编指令转成二进制编码，按指令表翻译汇编语言为0/1机器语言
- 输出：目标文件（`.o`/`.obj`文件）


### 4. 链接：
- **链接器**负责关联目标文件和链接库（静态链接库`.lib`、动态链接库`.dll`）（你装盗版软件肯定会遇上缺这些东西的情况）
- 输出：可执行文件（`.exe`文件）
