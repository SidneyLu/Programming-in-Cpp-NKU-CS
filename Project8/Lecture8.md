# 南开大学 高级语言程序设计 Lecture 8
STL（Standard Template Library，标准模板库）是C++标准库的核心组成部分，基于**泛型编程**思想设计，提供了一套高效、可复用的组件，涵盖数据结构（容器）、算法、迭代器等，旨在解决“重复开发基础功能”的问题。其核心价值是：**将数据结构与算法分离，通过迭代器连接，实现高度的代码复用与效率平衡**。  


## 一、STL的六大核心组件  
STL由六个相互协作的组件构成，核心关系为：**算法通过迭代器操作容器，仿函数和适配器扩展功能，分配器管理内存**。  

| 组件         | 作用                                                                 | 核心头文件                  |  
|--------------|----------------------------------------------------------------------|-----------------------------|  
| 容器（Container） | 管理数据集合的类模板（如动态数组、链表、哈希表等）                   | `<vector>`, `<list>`, `<map>` 等 |  
| 算法（Algorithm） | 操作容器元素的函数模板（如排序、查找、拷贝等）                       | `<algorithm>`, `<numeric>`   |  
| 迭代器（Iterator） | 连接容器与算法的“桥梁”，提供统一的元素访问接口                       | 各容器头文件中（如`vector::iterator`） |  
| 仿函数（Functor） | 重载`()`的类/结构体，可作为算法的参数（类似函数但可携带状态）         | `<functional>`              |  
| 适配器（Adapter） | 转换已有组件的接口，使其适配新场景（如栈适配自双向队列）             | `<stack>`, `<queue>`, `<functional>` |  
| 分配器（Allocator） | 负责容器的内存分配与释放（默认由系统提供，用户可自定义）             | `<memory>`                  |  


## 二、容器（Container）：数据结构的实现  
容器是STL中最常用的组件，用于存储和组织数据，按特性分为四类：**序列容器、关联容器、无序关联容器、容器适配器**。  


### 1. 序列容器（Sequence Containers）  
**特点**：元素按插入顺序排列，可通过位置访问，不自动排序。  
**核心容器**：  

| 容器         | 底层实现       | 核心特点                                                                 | 适用场景                     |  
|--------------|----------------|--------------------------------------------------------------------------|------------------------------|  
| `vector`     | 动态数组       | 随机访问快（O(1)），尾部插入/删除快（O(1)），中间插入/删除慢（O(n)）       | 频繁访问、尾部增删（如存储列表） |  
| `deque`      | 分段数组（双端队列） | 双端插入/删除快（O(1)），随机访问快（O(1)），内存碎片较`vector`多         | 双端频繁操作（如队列实现）   |  
| `list`       | 双向链表       | 任意位置插入/删除快（O(1)），不支持随机访问（O(n)），内存开销大           | 频繁插入/删除（如链表操作）   |  
| `forward_list` | 单向链表       | 比`list`更节省内存，仅支持单向遍历，插入/删除效率同`list`                 | 内存敏感的单向链表场景       |  


### 2. 关联容器（Associative Containers）  
**特点**：元素按“键（key）”排序（默认升序），通过键快速查找（底层通常为红黑树）。  
**核心容器**：  

| 容器         | 键-值关系      | 核心特点                                                                 | 适用场景                     |  
|--------------|----------------|--------------------------------------------------------------------------|------------------------------|  
| `set`        | 键即值（无重复） | 元素唯一，按键排序，查找/插入/删除O(log n)                               | 去重+排序（如索引集合）       |  
| `multiset`   | 键即值（可重复） | 元素可重复，其他同`set`                                                  | 允许重复的排序集合           |  
| `map`        | 键-值对（键唯一） | 键唯一，按键排序，通过键访问值O(log n)，支持`[]`操作符                   | 键值映射（如字典、配置表）   |  
| `multimap`   | 键-值对（键可重复） | 键可重复，无`[]`操作符，其他同`map`                                      | 一对多映射（如多值字典）     |  


### 3. 无序关联容器（Unordered Associative Containers）  
**特点**：元素不排序，通过哈希表实现，查找效率更高（平均O(1)）。  
**核心容器**：  

| 容器               | 键-值关系      | 核心特点                                                                 | 适用场景                     |  
|--------------------|----------------|--------------------------------------------------------------------------|------------------------------|  
| `unordered_set`    | 键即值（无重复） | 无序，哈希表实现，查找/插入/删除平均O(1)，最坏O(n)（哈希冲突严重时）       | 高频查找、无需排序（如去重） |  
| `unordered_multiset` | 键即值（可重复） | 允许重复元素，其他同`unordered_set`                                      | 允许重复的高频查找           |  
| `unordered_map`    | 键-值对（键唯一） | 无序，哈希表实现，支持`[]`，查找效率高于`map`                             | 高频键值查询（如缓存）       |  
| `unordered_multimap` | 键-值对（键可重复） | 键可重复，无`[]`，其他同`unordered_map`                                  | 一对多的高频查询             |  


### 4. 容器适配器（Container Adapters）  
**特点**：基于其他容器封装的“适配接口”，隐藏底层实现，提供特定功能。  
**核心容器**：  

| 容器         | 底层依赖       | 核心特点                                                                 | 适用场景                     |  
|--------------|----------------|--------------------------------------------------------------------------|------------------------------|  
| `stack`      | 默认`deque`    | 后进先出（LIFO），仅支持栈顶操作（push/pop/top）                          | 栈场景（如表达式求值）       |  
| `queue`      | 默认`deque`    | 先进先出（FIFO），支持队尾插入、队头删除（push/pop/front/back）            | 队列场景（如任务调度）       |  
| `priority_queue` | 默认`vector`   | 优先级最高元素先出（大顶堆），插入/删除O(log n)                           | 优先队列场景（如事件驱动）   |  


## 三、迭代器（Iterator）：容器与算法的桥梁  
迭代器是“泛型指针”，为所有容器提供统一的元素访问接口（`++`移动，`*`取值），使算法可跨容器复用。  


### 1. 迭代器的分类（按功能）  
STL将迭代器分为5类，决定了可支持的操作（如随机访问、双向遍历）：  

| 迭代器类型       | 支持的操作                                                                 | 对应容器举例                 |  
|------------------|----------------------------------------------------------------------------|------------------------------|  
| 输入迭代器（Input Iterator） | 只读，单向遍历（`++`），支持`==`/`!=`                                       | `istream_iterator`（输入流） |  
| 输出迭代器（Output Iterator） | 只写，单向遍历（`++`）                                                     | `ostream_iterator`（输出流） |  
| 前向迭代器（Forward Iterator） | 可读可写，单向遍历（`++`），支持多次遍历                                   | `forward_list`, `unordered_set` |  
| 双向迭代器（Bidirectional Iterator） | 可读可写，双向遍历（`++`/`--`）                                            | `list`, `set`, `map`          |  
| 随机访问迭代器（Random Access Iterator） | 可读可写，支持随机访问（`+n`/`-n`/`[]`），所有操作O(1)                      | `vector`, `deque`, `array`    |  


### 2. 迭代器的使用  
所有容器通过`begin()`获取起始迭代器（指向首元素），`end()`获取结束迭代器（指向尾元素后一位），算法通过这两个迭代器操作容器：  
```cpp
#include <vector>
#include <algorithm> // 包含sort算法

std::vector<int> v = {3, 1, 4};
// 获取迭代器
auto it = v.begin(); 
*it = 2; // 修改首元素（v变为{2,1,4}）

// 算法通过迭代器操作容器（排序）
std::sort(v.begin(), v.end()); // v变为{1,2,4}
```  


## 四、算法（Algorithm）：操作容器元素的工具  
STL算法是一系列泛型函数模板，通过迭代器操作容器元素，不依赖具体容器类型，分为四大类：  


### 1. 非修改型算法（Non-modifying Algorithms）  
不改变容器元素的内容或顺序，用于查询、计数等：  
- `find(begin, end, val)`：查找值为`val`的元素，返回迭代器；  
- `count(begin, end, val)`：统计`val`出现的次数；  
- `for_each(begin, end, func)`：对每个元素执行`func`操作。  


### 2. 修改型算法（Modifying Algorithms）  
改变容器元素的内容或顺序：  
- `copy(begin1, end1, begin2)`：拷贝元素到另一个容器；  
- `fill(begin, end, val)`：用`val`填充容器；  
- `transform(begin1, end1, begin2, func)`：对元素应用`func`，结果存入另一个容器。  


### 3. 排序与相关算法（Sorting Algorithms）  
对容器元素排序或利用有序性操作：  
- `sort(begin, end)`：对元素排序（默认升序）；  
- `binary_search(begin, end, val)`：在有序容器中二分查找`val`；  
- `merge(begin1, end1, begin2, end2, begin3)`：合并两个有序容器。  


### 4. 数值算法（Numeric Algorithms）  
用于数值计算（需包含`<numeric>`）：  
- `accumulate(begin, end, init)`：累加元素（`init`为初始值）；  
- `inner_product(begin1, end1, begin2, init)`：计算两个序列的内积。  


## 五、仿函数（Functor）：可携带状态的“函数”  
仿函数是重载`operator()`的类或结构体，行为类似函数，但可通过成员变量携带状态，常作为算法的参数（如自定义排序规则）。  

**示例**：用仿函数定义降序排序规则  
```cpp
#include <vector>
#include <algorithm>

// 仿函数：定义降序比较
struct Greater {
    bool operator()(int a, int b) const {
        return a > b; // 若a > b，返回true（即a应排在b前）
    }
};

int main() {
    std::vector<int> v = {3, 1, 4};
    // 用仿函数作为sort的参数，实现降序排序
    std::sort(v.begin(), v.end(), Greater()); // v变为{4,3,1}
    return 0;
}
```  

标准库提供了常用仿函数（如`<functional>`中的`std::less`、`std::greater`、`std::plus`等）。  


## 六、适配器（Adapter）：接口转换工具  
适配器用于转换已有组件的接口，使其满足新需求，分为三类：  


### 1. 容器适配器（Container Adapter）  
如`stack`、`queue`、`priority_queue`，基于其他容器（如`deque`、`vector`）封装，提供简化接口（见“容器”部分）。  


### 2. 迭代器适配器（Iterator Adapter）  
转换迭代器的行为，如：  
- `reverse_iterator`：反转迭代方向（`rbegin()`/`rend()`返回反向迭代器）；  
- `insert_iterator`：将赋值操作转为插入操作（如`back_inserter`在容器尾部插入）。  


### 3. 函数适配器（Function Adapter）  
修改仿函数或函数的接口，如：  
- `std::bind`：绑定函数参数（固定部分参数，返回新函数对象）；  
- `std::not1`：对一元仿函数取反（如`not1(Greater())`表示“不大于”）。  


## 七、分配器（Allocator）：内存管理的幕后推手  
分配器负责容器的内存分配、释放、对象构造与析构，隐藏了底层内存管理细节。默认情况下，容器使用`std::allocator`，但用户可自定义分配器（如实现内存池优化性能）。  

**示例**：容器与分配器的关联（默认可省略）  
```cpp
#include <vector>
#include <memory> // 包含std::allocator

// vector默认使用std::allocator<int>
std::vector<int, std::allocator<int>> v; 
```  


## 八、STL的设计思想  
1. **泛型编程**：通过模板实现“参数化类型”，使容器和算法独立于具体数据类型；  
2. **分离原则**：容器（数据）与算法（操作）分离，通过迭代器连接，降低耦合；  
3. **效率优先**：底层数据结构（如红黑树、哈希表）和算法（如快速排序）均经过优化，保证高性能；  
4. **接口统一**：所有容器提供一致的接口（`begin()`/`end()`/`size()`等），降低学习成本。  


## 九、总结  
STL是C++开发的“瑞士军刀”，其核心价值在于：  
- **复用性**：无需重复实现基础数据结构和算法；  
- **高效性**：经过严格优化的底层实现，性能接近手写最优代码；  
- **灵活性**：通过泛型设计支持任意数据类型，适配多样场景。  

掌握STL的关键是理解“容器-迭代器-算法”的三角关系，根据场景选择合适的容器（如高频查找用`unordered_map`，频繁插入用`list`），并善用算法和仿函数简化逻辑。