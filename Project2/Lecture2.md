# 南开大学 高级语言程序设计 Lecture 2

上一讲我们学习了C++的变量、数据类型与基本语法，但若想编写实用程序，还需解决两个核心问题：**如何控制程序执行流程**（让程序能“做选择”“重复做”）、**如何规范输入输出格式**（让数据展示更清晰）。


## 一、分支结构：让程序“做选择”  
分支结构根据条件执行不同代码块，是实现“逻辑判断”的基础，核心分为`if`系列（处理连续条件）和`switch`（处理离散值）两类。


### 1.1 `if-else`：二选一逻辑  
适用于“满足条件执行A操作，不满足则执行B操作”的场景，例如判断学生成绩是否合格、判断数字是否为正数等。  

- **核心逻辑**：先判断“条件表达式”（结果为`true`或`false`，非0值视为`true`，0视为`false`），若为`true`则执行`if`后的代码块，否则执行`else`后的代码块。  
- **避坑提醒**：必须区分比较运算符`==`（判断“是否相等”）和赋值运算符`=`（将值赋给变量）——若误写为`if (score = 60)`，会将60赋值给`score`，导致条件恒为`true`，出现逻辑错误。  
- **代码块规则**：C++以大括号`{}`划分代码块，而非依赖缩进；即使代码块只有一行，也建议保留`{}`，避免后续添加代码时遗漏范围，引发错误。


### 1.2 `if-else if-else`：多条件判断  
适用于“存在多个互斥条件，需按优先级匹配执行”的场景，例如根据分数区间评定成绩等级（90+为A、80-89为B、60-79为C、60以下为D）、根据年龄划分年龄段等。  

- **条件顺序关键**：需按“条件严格程度”排序（如先判断90+，再判断80+，最后判断60+）——若将宽松条件（如60+）放在前面，会导致严格条件（如90+）永远无法匹配（例如85分会直接被60+的条件捕获，误判为C）。  
- **默认分支作用**：`else`作为最后一个分支，用于处理“所有条件均不匹配”的情况，确保程序不会因未覆盖的情况出现逻辑漏洞（例如输入负数成绩时，通过`else`提示“成绩无效”）。


### 1.3 `switch`：离散值匹配  
适用于“判断对象为整数、字符或枚举类型等离散值”的场景，例如菜单选择（1为添加、2为删除、3为查询）、根据星期几执行对应操作等，比`if-else if`更简洁高效。  

- **核心逻辑**：先计算“表达式”的值，再与各个`case`后的“常量值”匹配，找到匹配项后执行对应代码；若所有`case`均不匹配，则执行`default`后的代码。  
- **关键注意点**：  
  1. `case`后必须跟“常量”（不能是变量或表达式），例如`case 1`合法，`case x`（x为变量）不合法；  
  2. 每个`case`分支需用`break`终止——若遗漏`break`，会触发“case穿透”（执行完当前`case`后，继续执行下一个`case`，例如选择“1”时同时执行“添加”和“删除”操作）；  
  3. `default`可选但推荐添加，用于处理“无效输入”（如菜单选择4时提示“无效操作”）；  
  4. C++17新增`[[fallthrough]]`属性：若需主动实现“穿透”（如多个`case`执行相同逻辑），可在对应`case`末尾添加`[[fallthrough]];`，显式标记穿透意图，提升代码可读性。


### 1.4 C++17 分支初始化（进阶）  
C++17新增“分支内变量初始化”语法，允许在`if`或`switch`语句中直接声明并初始化变量，变量的作用域仅限于当前分支块内。  

- **核心优势**：避免变量污染外部作用域——例如在`if`中初始化的变量，仅能在`if`和对应的`else`块内使用，外部无法访问，减少变量名冲突风险。  
- **适用场景**：当变量仅用于分支内的条件判断或逻辑处理时（如判断临时计算结果、临时存储输入值），无需在分支外声明变量，简化代码结构。


## 二、循环结构：让程序“重复做”  
循环结构用于重复执行一段代码，直到满足终止条件，是实现“批量处理”“迭代计算”的核心，根据“是否已知循环次数”可分为`for`、`while`和`do-while`三类。


### 2.1 `for`循环：已知循环次数  
最常用的循环类型，适用于“循环次数明确”的场景，例如遍历1~100的数字、计算数组元素和、重复执行固定次数的操作等。  

- **三要素解析**：`for`循环的语法格式为`for (初始化; 循环条件; 迭代)`，三要素各司其职：  
  1. 初始化：循环开始前执行一次，通常用于定义并初始化“循环变量”（如`int i = 1`），明确循环的起始状态；  
  2. 循环条件：每次循环前判断，结果为`true`则执行循环体，为`false`则终止循环（如`i <= 100`），定义循环的终止边界；  
  3. 迭代：每次循环后执行，通常用于更新循环变量（如`i++`），确保循环条件最终会变为`false`，避免死循环。  
- **优势**：将“初始化、条件、迭代”集中在一行，结构紧凑，便于阅读和维护，减少因循环变量管理不当导致的错误。


### 2.2 `while`循环：未知循环次数  
适用于“循环次数不确定，仅知道终止条件”的场景，例如“累加数字直到和超过1000”“读取用户输入直到输入‘退出’”等。  

- **核心逻辑**：先判断“循环条件”（结果为`true`或`false`），若为`true`则执行循环体，执行后再次判断条件，直至条件为`false`时终止。  
- **死循环预警**：`while`循环的循环变量需在“循环体内手动更新”（如累加场景中`num++`）——若遗漏更新操作，循环条件会永远为`true`，程序陷入“死循环”（需通过`Ctrl+C`强制终止）。  
- **适用场景**：当循环次数依赖动态结果（如用户输入、实时计算值）时，`while`比`for`更灵活，无需预先确定循环次数。


### 2.3 `do-while`循环：至少执行一次  
适用于“循环体至少需要执行一次”的场景，例如“密码验证（至少输入一次密码）”“菜单循环（至少显示一次菜单）”等。  

- **核心区别**：与`while`的唯一差异是“执行顺序”——`do-while`先执行一次循环体，再判断“循环条件”；而`while`先判断条件，再执行循环体。这意味着即使条件初始为`false`，`do-while`的循环体也会执行一次。  
- **使用注意**：`do-while`的语法末尾需加“分号”（`do { ... } while (条件);`），避免语法错误。


### 2.4 循环控制：`break`与`continue`  
用于精细调整循环执行流程，解决“提前终止循环”“跳过部分迭代”的需求，是循环结构的重要补充。  

- **`break`：立即终止循环**  
  执行到`break`时，会直接跳出当前循环（不再判断条件，也不执行后续迭代），适用于“找到目标值后终止”“满足特定条件时退出”的场景，例如“遍历数组找到指定元素后停止”“输入‘退出’时终止循环”。  

- **`continue`：跳过本次迭代**  
  执行到`continue`时，会跳过当前循环体的剩余代码，直接进入“下一次迭代的条件判断”，适用于“跳过特定值的处理”，例如“遍历1~10时跳过偶数”“统计成绩时跳过负数”。  

- **记忆技巧**：`break`是“彻底打断循环”，`continue`是“继续下一次循环”，二者均仅作用于“当前所在的循环层”（嵌套循环中不影响外层循环）。


## 三、格式控制：让输出更规范（告别复杂格式串）  
掌握流程控制后，需通过格式控制让输入输出更易读、更符合需求。传统`printf`的格式串（如`%.2f`）易混淆，C++提供更友好的方案，核心依赖`<iomanip>`库、C++20`format`库及字符串工具。


### 3.1 基础工具与核心概念  
先掌握两类基础操作：转义字符（控制输出结构）和类型转换（适配数据需求），是格式控制的前提。  

- **常用转义字符**：用于调整输出格式，避免文本混乱，高频转义字符包括：  
  - `\n`：换行（将光标移至下一行开头）；  
  - `\t`：制表符（相当于按一次Tab键，用于对齐文本）；  
  - `\\`：输出反斜杠（因`\`在C++中是转义符，需用`\\`表示字面意义的`\`）；  
  - `\"`/`\'`：输出双引号/单引号（避免与字符串的引号冲突）。  

- **常用类型转换**：解决“数据类型不匹配”的问题，确保格式控制时数据类型正确：  
  - `static_cast<目标类型>(值)`：安全的强制类型转换，例如将`double`类型的小数转为`int`（截断小数部分），避免隐式转换的不确定性；  
  - `to_string(值)`：将数值（int、double等）转换为字符串类型，便于拼接文本（如将“成绩：”与分数拼接为完整字符串）。


### 3.2 `<iomanip>`库：传统流格式化  
`<iomanip>`是C++传统的格式化库，通过“控制符”直接修饰`cout`（标准输出流），实现小数精度、文本对齐、填充等效果，无需记忆复杂格式串。  

- **核心控制符功能**：  
  1. `setprecision(n)`：控制浮点数的精度——无`fixed`时表示“有效数字位数”（如`setprecision(3)`使3.1415输出为3.14），有`fixed`时表示“小数位数”（如`fixed << setprecision(3)`使3.1415输出为3.142）；  
  2. `fixed`/`scientific`：`fixed`将浮点数按“固定小数位”显示，`scientific`按“科学计数法”显示（如3.14e+00），可通过`cout.unsetf(ios::fixed)`取消对应格式；  
  3. `setw(n)`：设置输出内容的“宽度”（单位为字符），仅对“下一个输出项”生效——若内容长度不足n位，会用“填充字符”补全（默认填充空格）；  
  4. `left`/`right`：设置文本对齐方式——`left`为左对齐（填充字符在右侧），`right`为右对齐（填充字符在左侧），需配合`setw`使用；  
  5. `setfill(c)`：指定“填充字符”（如`setfill('*')`将填充字符设为`*`），仅在`setw`生效时起作用。  


### 3.3 C++20 `format`库：直观的格式化新方案  
C++20引入的`format`库是格式化输出的“现代方案”，语法类似Python的f-string，将格式说明直接嵌入字符串，可读性和易用性大幅提升，推荐在支持C++20的环境中优先使用。  

- **核心优势**：格式说明与文本内容融合，无需记忆独立控制符，例如“输出保留3位小数的pi值”可直接写为`format("pi = {:.3f}", pi)`，直观易懂。  
- **格式说明规则**：格式占位符的语法为`{:[填充符][对齐][宽度].[精度][类型]}`，各部分可选，例如：  
  - `{:.3f}`：保留3位小数的浮点数；  
  - `{:>10}`：宽度为10、右对齐的内容；  
  - `{:*<8}`：宽度为8、左对齐、用`*`填充的内容；  
  - `{:.2e}`：保留2位小数的科学计数法表示。  


### 3.4 原始字符串与整行输入  
解决“多行文本输出”和“含空格输入”的痛点，是格式控制中处理特殊文本的重要工具。  

- **原始字符串字面量（C++11）**：  
  用`R"(内容)"`标记，可直接包含多行文本和特殊字符（如`\n`、`\t`），无需转义——例如输出多行图案、正则表达式时，无需手动添加转义符，直接保留原始格式，大幅减少代码冗余和错误。  

- **整行输入（`getline`）**：  
  传统`cin >> 变量`会以“空格或换行”为分隔符，无法读取含空格的文本（如“张三 20”会被拆分为“张三”和“20”）；而`getline(cin, 字符串变量)`可读取“一整行文本”（包括空格），直到遇到换行符为止。  
  - **避坑提醒**：若之前用`cin >> 变量`读取过数据（如整数、浮点数），输入缓冲区会残留“换行符”，直接调用`getline`会读取到空行——需先通过`cin.getline(nullptr, 0)`清除缓冲区残留，再执行`getline`。

