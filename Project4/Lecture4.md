# 南开大学 高级语言程序设计 Lecture 4  

## 一、引用：变量的“别名”
### 左值引用
#### 1. 核心定义与本质  
- **概念**：引用是已存在变量的“别名”——不占用独立内存空间，与原变量共享同一块内存，操作引用等价于直接操作原变量。  
- **语法**：`类型& 引用名 = 原变量名;`（必须初始化，且初始化后不可更改指向）。  


#### 2. 核心用途：解决“拷贝冗余”与“指针复杂”  
##### （1）优化函数参数传递（避免值拷贝）  
值传递会生成变量副本（大型对象拷贝开销大），引用传递直接操作原变量，无拷贝成本：  

##### （2）替代指针，简化间接操作  
需“间接修改变量”时，引用无需解引用（`*`），比指针更直观、无野指针风险：  

### 右值引用
右值引用是C++11引入的特性，专为处理“临时值”设计，核心价值是解决临时对象的“无意义拷贝”问题，提升程序性能。

#### 1. **核心定义与本质**：
- **概念**
   - 左值：可被取地址、能放在赋值号左边的“持久值”（如变量 `a`、数组元素 `arr[0]`）；  
   - 右值：不可被取地址、只能放在赋值号右边的“临时值”（如常量 `5`、表达式 `a+3`、函数返回的临时对象）。  

- **语法**：`类型&& 引用名 = 右值;`    


#### 2. **核心用途：移动语义**  
   对于大型对象（如 `std::vector`、自定义类对象），函数返回的临时对象会先被拷贝到目标变量，再销毁临时对象——这是“无意义的拷贝”。  
   右值引用可直接“接管”临时对象的内存（而非拷贝），避免开销，这就是“移动语义”。  
   **妈妈再也不用担心我返回局部变量啦！**  


## 二、函数：代码的“模块化积木”  

### 1. 为什么需要函数？—— 从“堆砌”到“有序”  
前序章节代码均在 `main` 内，逻辑复杂时会出现：  
- 重复代码多（如多次用同一公式计算，需复制粘贴）；  
- 可读性差（数百行代码挤在一起，难定位逻辑）；  
- 维护难（修改一个逻辑需改所有复制处）。  

**函数**通过封装独立功能的代码块，实现“一次定义、多次调用”，解决上述问题。  


### 2. 函数的核心结构与语法  
函数包含「声明-定义-调用」三个环节，类比数学“y = f(x)”的输入-处理-输出逻辑：  

| 环节       | 语法格式                                                                 | 作用                                                                 |
|------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 函数声明   | `返回值类型 函数名(参数列表);`                                           | 告诉编译器：函数的“名字、输入类型、输出类型”，确保调用时匹配         |
| 函数定义   | `返回值类型 函数名(参数列表) { 函数体; return 返回值; }`                  | 实现函数的具体逻辑，`return` 语句返回结果（`void` 类型可省略）       |
| 函数调用   | `函数名(实参列表);` 或 `变量 = 函数名(实参列表);`                        | 执行函数逻辑，实参为实际传入的值，需与形参的个数/类型匹配           |  


### 3. 基础实践：三类典型函数示例  
#### （1）有返回值、有参数（如计算两数之和）  

#### （2）无返回值、有参数（如打印奇偶性）  
无需返回结果时，返回值类型用 `void`：  

#### （3）无参数、有返回值（如获取固定值）  
无需输入时，参数列表为空（可写 `void` 或留空）：  

### 4. 进阶特性：让函数更灵活  
#### （1）默认参数（调用时可省略部分参数）  
给形参指定默认值，需从右往左连续设置（避免歧义）：  

#### （2）函数重载（“同名不同参”，复用函数名）  
允许同名函数，需满足“参数个数不同”或“参数类型不同”（编译器通过参数区分）：  

#### （3）函数与数组结合（需手动传长度）  
数组作为参数时会“退化”为指针，无法直接获取长度，需额外传入：  


## 三、函数指针：指向“函数”的指针  
### 1. 核心定义与本质  
- **概念**：指针变量存储的是“变量的地址”，而**函数指针**存储的是“函数的入口地址”——通过函数指针可间接调用函数，实现“函数的动态切换”。  
- **本质**：函数在内存中占据一块连续空间，其入口地址就是函数名（类似数组名是首元素地址）。  


### 2. 函数指针的语法 
需明确“指向函数的返回值类型”和“参数列表”，格式为：  
`返回值类型 (*指针名)(参数列表);`  

括号不可省略：`(*指针名)` 表明这是指针，后面的 `(参数列表)` 表明指向函数。  

### 3. 核心用途：实现“函数的动态切换”  
当需要根据条件选择不同函数时，函数指针无需写大量 `if-else`，直接切换指针指向即可（典型场景：计算器的运算切换）：  
同时也可以为模板函数指定用户自定义的实现，如多种排序算法

## 四、常见错误与避坑指南  
| 知识点       | 常见错误                                                                 | 规避方法                                                                 |
|--------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 引用         | 未初始化引用；试图更改引用指向；左值引用绑定临时值                         | 引用必须初始化；接受“指向不可改”特性；临时值用右值引用（后续课程）绑定   |
| 函数         | 未声明直接调用；返回值类型不匹配；数组参数漏传长度                         | 函数定义在main后需提前声明；返回值与声明一致；数组参数必传长度           |
| 函数指针     | 省略括号（如 `int *func_ptr(int, int)` 变成函数声明）；参数/返回值类型不匹配 | 严格写 `(*指针名)` 括号；确保指针类型与指向函数的“返回值+参数”完全一致 |  
